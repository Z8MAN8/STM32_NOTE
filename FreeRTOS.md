## FreeRTOS

### 简介：

FreeRTOS 是一个支持多任务的操作系统。在 FreeRTOS 中，任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其它任务运行，任何数量的任务可以共享同一个优先级。
FreeRTOS可以创建多个任务，但是对于单核cpu来说，在任意给定时间，实际上只有一个任务被执行，这样就可以把任务分成2个状态，即运行状态和非运行状态。当任务处于运行状态时，处理器就执行该任务的代码。处于非运行态的任务，它的所有寄存器状态都保存在自己的任务堆栈中，当调度器将其恢复到运行态时，会从上一次离开运行态时正准备执行的那条指令开始执行。



### FreeRTOS中任务的特性：

1. 简单易用
2. 没有使用限制
3. 支持抢占、支持优先级
4. 每个任务都有自己的堆栈，对RAM消耗较多

**FreeRTOS任务函数一般不允随意跳出循环，如果要关闭任务要使用VTaskDelete()来删除任务。**



### 任务的状态：

运行态、就绪态、阻塞态、挂起态和删除态。

**运行态（Running）：**说明当前CPU 正在执行该任务，单核处理器任何时刻只有一个任务处于运行态。处于就绪态就说明该任务正在占用CPU。

**就绪态（Ready）：**说明任务已经就绪，可以被任务调度器调用去执行，但是调度只会去执行目前优先级最高的任务。

**阻塞态（Blocked）：**阻塞态的任务不会被任务调度器的调度，并且任务阻塞是有一定时间的，当超过时间结束会退出阻塞状态。处于阻塞状态的作用除了可以使任务处于暂停状态，还有一个作用是灵活调度，当任务处于阻塞状态，调度器就会去执行其它任务，提高效率。比如当某个任务调用**TaskDelay** 毫秒延时函数时，该**任务就会阻塞**，同时调度器自动运行其它处于就绪态的任务，**等待延时结束时重新进入就绪态**。

**挂起态（Suspend）：**处于挂起态的任务同样不会被任务调度器调度，但是对比阻塞态它没有超时时间，当调用当明确的分别调用**vTaskSuspend()**和**xTaskResume()** 函数后，任务才会**进入或退出挂起状态**。

**删除态：**任务删除之后任务控制块TCB 会保留一段时间，等待内核检查和回收资源，任务也不能再被调度，此时任务处于删除态。

CMSIS-RTOS 拥有四个状态：就绪态、运行态、阻塞态和终止态，它和FreeRTOS中的状态有所区别，CMSIS-RTOS 的阻塞态合并了FreeRTOS 中的挂起态和阻塞态，终止态对应的是FreeRTOS 中的删除态。



### 任务管理调度的方法：

**抢占式调度：**当有新的任务就绪（ready），且优先级大于等于当前任务的优先级时，当前任务就会被抢占；需要用户自己通过**configUSE_PREEMPTION**配置。

**时间片调度：**同处于ready态的最高优先级的任务会轮流运行固定的时间片；通过**configUSE_TIME_SLICING**配置，**默认开启**



### 任务优先级：

**任务的优先级**由数字决定的，**数字越大**优先级**越高**，数字**越小**代表优先级**越低**。用户实际可以使用的优先级范围是0到configMAX_PRIORITIES–1

**中断优先级和任务优先级是没有任何关系的**，中断优先级的**数字越大**代表优先级**越低**，数字**越小**代表优先级**越高**。**中断的级别永远高于任务级别**。当任务开始执行的时候中断发生，微处理器会立刻执行中断服务程序。



### 任务的堆栈空间：

FreeRTOS 中的每个任务都有一个堆栈空间，任务堆栈可以由系统提供，也可以由用户提供。

当由**系统提供时使用xTaskCreate()函数**，此时需要将申请的**任务堆栈的大小作为形参传入**。

当由**用户自行提供的时候使用xTaskCreateStatic()函数**，此时需要将用户提供的**堆栈空间的地址作为形参传入**。

在使用**静态方法创建线程**时，必须先定义静态的线程控制块，并且定义好堆栈空间。采用这种方式，**线程控制块和堆栈占用的内存会放在 RW/ZI段**（详细请看ARM架构中RO段，RW段，ZI段的区别），这段空间在编译时就已经确定，它不是动态分配的，所以**不能简单用osThreadTerminate()释放空间**，只能使用它将该线程控制块从任务管理器中脱离。

使用**动态方法创建线程**时， 线程会动态申请线程控制块和堆栈空间。在编译时， 编译器是不会感知到这段空间的，只有在程序运行时， 线程才会从系统堆中申请分配这段内存空间，当不需要使用该线程时，在CMSIS提供的接口中，调用**osThreadTerminate()函数就会将这段申请的内存空间重新释放到内存堆中**。

这两种方式各有利弊，静态定义方式会占用 RW/ZI空间，但是不需要动态分配内存，运行时效率较高，实时性较好。 动态方式不会占用额外的 RW/ZI空间，占用空间小，但是运行时需要动态分配内存，效率没有静态方式高。 总的来说，这两种方式就是空间和时间效率的平衡，可以根据实际环境需求选择采用具体的分配方式。





#### 详细资料链接：https://blog.csdn.net/qq_41047485/article/details/108405606